{
  "projectInstructions": "You are assisting on a TypeScript fullstack monorepo template designed to serve as a reusable foundation for multiple applications.\n\nStack:\n- Monorepo: Nx, pnpm workspaces\n- Frontend: Next.js 15 (App Router), Tailwind CSS, shadcn/ui, Clerk auth, React Hook Form + Zod\n- Backend: NestJS (modular, CLI-managed), Prisma ORM (Postgres via Supabase), BullMQ (for jobs, Redis), tRPC (type-safe API contracts)\n- API Layer: tRPC (contract in /libs/api-contract)\n- Dev Tooling: GitHub, Vercel (frontend deploy), Fly.io (backend deploy), Supabase (DB), Clerk (auth)\n- Testing: Jest, Playwright\n\nArchitecture:\n- Use Clean Architecture: domain/, application/, infrastructure/, presentation/ layering\n- Use Domain-Driven Design: modular, clear bounded contexts, rich domain models\n- Use Nx for project orchestration and atomic changes\n- Use a modular monolith approach for the backend in the MVP: each bounded context should be implemented as a clearly separated module within a single deployable application, making future extraction to independent services straightforward if needed. Maintain strong internal boundaries and minimal coupling between modules.\n\nDevelopment Conventions:\n- For the MVP, use a single shared database instance with all tables in the default `public` schema unless there is a clear benefit to further isolation. Maintain strict code and repository boundaries between bounded contexts, and clearly document table ownership. If using multiple schemas for extra isolation, ensure all tooling, migrations, and cloud services (e.g., Supabase) fully support this setup and test accordingly.\n- All new features follow Clean Architecture and DDD principles.\n- Favor explicit folder structure: /domain, /application, /infrastructure, /presentation for both apps and libs.\n- Shared types and API contracts live in /libs/api-contract\n- tRPC should provide type-safe contract between frontend and backend.\n- Code should be idiomatic TypeScript.\n- Use Prisma for all DB interactions (define schema in /prisma/schema.prisma, run migrations via CLI).\n- Use Tailwind and shadcn/ui for all UI; do not use other UI frameworks.\n- Authentication should be handled via Clerk (Next.js integration).\n- Unit and integration tests should be written for all logic; prefer Jest for unit, Playwright for E2E.\n- All code should have corresponding Jest unit tests; important flows should have Playwright E2E tests.\n- Write tests in clearly named folders (e.g., __tests__/ for unit, /e2e/ for end-to-end).\n- All API inputs and outputs must be validated with Zod schemas (tRPC procedures must be safe by default).\n- For any public endpoints, ensure rate limiting and authentication checks.\n- All errors should be logged and reported via Sentry where possible.\n- Use structured logging with Pino in backend services. Implement monitoring and alerting for errors and significant system events in both backend and frontend applications.\n- For feature flags, implement a database-backed model managed via AdminJS. Feature flag access should be abstracted via a utility library in the monorepo, supporting in-memory caching and per-user/tenant overrides if needed. Wrap all new features in feature flag checks as appropriate.\n- For analytics, prefer PostHog or a similar tool.\n- Use AdminJS for rapid scaffolding of admin features and CRUD dashboards when required.\n- For asynchronous/background processing, use BullMQ. For cross-context events, model event payloads to be compatible with CloudEvents spec, even if not serialized as such internally. Only introduce internal event-driven communication (e.g., with nestjs-event-emitter) for cross-context domain events. Do not use events for intra-module logic.\n- For synchronous, strongly-coupled service-to-service communication between independently deployed TypeScript services, use tRPC as the primary API transport. If future clients are not TypeScript-based, consider gRPC or OpenAPI for interop.\n- All user-facing features must be built with internationalization (i18n) in mind. Do not hardcode user-facing strings; instead, use an i18n library (such as next-intl or next-i18next) and maintain translations via separate files or translation keys from the start.\n- All environment-specific configuration and secrets must be handled via .env files and environment variables. Never hardcode credentials or secrets in code. Document all required environment variables in a sample .env.example file.\n- Every new module, service, or significant feature should be accompanied by minimal documentation. The project must always include an up-to-date README.md covering local development, deployment, and high-level architecture. For larger codebases, maintain additional documentation under /docs or similar.\n- For any public REST APIs, generate and maintain an OpenAPI (Swagger) specification. Use Docusaurus as the developer portal, integrating the OpenAPI plugin to provide interactive and versioned API documentation alongside guides, onboarding, and code samples. All public API features must be fully documented before release.\n\nWorkflow:\n- Generate code in Nx-compatible structure.\n- When creating new entities or modules, generate folders and files according to Clean Architecture:  \n  - domain/ (entities, value objects, aggregates, domain services)\n  - application/ (use-cases, DTOs, input/output ports, application services)\n  - infrastructure/ (repositories, adapters, external integrations)\n  - presentation/ (controllers, resolvers, API routes, UI)\n- Prefer dependency injection and testable code.\n- For new API endpoints:  \n  - Define contract in libs/api-contract\n  - Implement handler in NestJS (presentation → application → domain → infrastructure)\n  - Expose to frontend via tRPC client\n- Use tRPC’s Zod schemas for input/output validation.\n- For all multi-step implementation requests, first output a proposed step-by-step plan before writing any code. Wait for explicit user confirmation before proceeding with each step. Do not generate the full implementation in a single response—work incrementally and only move to the next step after approval.\n\nCode Style:\n- Idiomatic, readable TypeScript (strict mode)\n- Use ES2022+ features\n- Consistent with Prettier/ESLint\n- Comments where business/domain logic is non-obvious\n\nTesting:\n- Always provide a basic Jest test when creating new modules/use-cases\n- Playwright tests for important user flows\n\nOther:\n- If asked for infrastructure code (deployment, CI/CD), keep it explicit and minimal (not over-abstracted)\n- Assume most devs have used modern TypeScript, React, and Node, but are new to this specific stack.\n\nALWAYS:\n- Structure code for clarity, maintainability, and testability.\n- Prioritize Clean Architecture boundaries and explicit DDD module layout.\n- Provide explanations for generated code when logic is non-trivial."
}
